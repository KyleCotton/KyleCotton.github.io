[{"categories":null,"content":"About Hi I’m Kyle Cotton a third year Computer Science student at the University of Edinburgh. I’m personally interested in Computer \u0026 Network Security. ","date":"12/05/2020","objectID":"/about/:1:0","tags":["Meta"],"title":"About","uri":"/about/"},{"categories":null,"content":"Contact Here are the ways you can get in touch with me I prefer email though. Lets talk code GitHub Shoot me an Email Lets IM over Telegram ","date":"12/05/2020","objectID":"/about/:2:0","tags":["Meta"],"title":"About","uri":"/about/"},{"categories":["Haskell for Beginners"],"content":"Welcome to my first post in a series on Haskell. In this series I will be covering a range of beginner topics; the series may continue to me covering more advanced topics. ","date":"24/05/2019","objectID":"/an-introduction-to-haskell/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"An Introduction to Haskell","uri":"/an-introduction-to-haskell/"},{"categories":["Haskell for Beginners"],"content":"In this episode we will be installing Haskell, a lot of people struggle to install software to their machine and each operating system will be different, generally I advise the use of a package manger - not just to install Haskell, but to install all software. I will be making a post about Brew at some point which makes this process trivial. ","date":"25/05/2019","objectID":"/installing-haskell/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Installing Haskell","uri":"/installing-haskell/"},{"categories":["Haskell for Beginners"],"content":"MacOS MacOS my operating system of choice, to install Haskell on a MacOS system, the best method is to use a package manager such as Brew. If you don’t have Brew installed, follow the link and install that. Brew is one of my essential utilities for any new Mac. Open your favourite terminal emulator such as Terminal.app, pre-installed on all Macs. From your command line run, brew install ghc, this will install the latest version of the Glasgow Haskell Compiler Happy Days! Haskell is now installed. ","date":"25/05/2019","objectID":"/installing-haskell/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Installing Haskell","uri":"/installing-haskell/"},{"categories":["Haskell for Beginners"],"content":"Linux Open your favourite terminal emulator such as Terminal. Using your favourite package manager install ghc, this will install the latest version of the Glasgow Haskell Compiler Happy Days! Haskell is now installed. ","date":"25/05/2019","objectID":"/installing-haskell/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Installing Haskell","uri":"/installing-haskell/"},{"categories":["Haskell for Beginners"],"content":"Windows A lot of software we use in Computer Science does run on Windows, but it does not play nice, lets fix that. If your don’t have WSL (Windows Subsystem for Linux), go install that first Congratulations, your avoiding Windows, now follow the Linux instructions. ","date":"25/05/2019","objectID":"/installing-haskell/:3:0","tags":["Programming","Tutorial","Haskell"],"title":"Installing Haskell","uri":"/installing-haskell/"},{"categories":["Haskell for Beginners"],"content":"In this post I will be giving an insight in reading haskell documentation ","date":"26/05/2019","objectID":"/understanding-haskell-documentation/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Understanding Haskell Documentation","uri":"/understanding-haskell-documentation/"},{"categories":["Haskell for Beginners"],"content":"Product Example product :: Num a =\u003e [a] -\u003e a -- The product function computes the product of a finite list of numbers. Above is an extract from the Haskell documentation. Line 1 shows the Type Signature of the product function, this shows the types of the inputs and the outputs in a convenient way. All functions in Haskell return a single object, this could be a single number, tuple, list etc. The first part of this statement Num a is called a Type Class this is a more advanced topic and something we will discuss later. The final part of the statement [a] -\u003e a this is showing a list of something is given to the product function and a single something is returned. The type of the something must be a Num as it is stated in the Type Class. ","date":"26/05/2019","objectID":"/understanding-haskell-documentation/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Understanding Haskell Documentation","uri":"/understanding-haskell-documentation/"},{"categories":["Haskell for Beginners"],"content":"Appending Two Lists (++) :: [a] -\u003e [a] -\u003e [a] -- Append two lists Above is an extract from the Haskell documentation. Again line 1 shows the Type Signature of the append operator. We know haskell returns only a single object so we know what the final [a] represents that means that the first two [a] must be the inputs to the function. So this function takes two lists of the same type (both are parameterised with a) and returns a new list of the same type of the input. ","date":"26/05/2019","objectID":"/understanding-haskell-documentation/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Understanding Haskell Documentation","uri":"/understanding-haskell-documentation/"},{"categories":["Haskell for Beginners"],"content":"Functions, functions, functions; Haskell is all about functions. When writing Haskell code we create, compose and apply functions to achieve our goal. ","date":"27/05/2019","objectID":"/functions/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"What is a function In Haskell a function takes one or more things (referred to as arguments), and will give you back something else (referred to as the output or return value). So to recap, a Haskell function takes something and gives something else back. This is all a ‘normal’ function can do in Haskell, I will discuss the ‘non-normal’ functions, ones that can effect the program state later, they are more advanced. ","date":"27/05/2019","objectID":"/functions/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Kinds of Data So we know what a function is, so what can I give it. In other words what types can the function accept. Some commonly used data types defined in prelude (the standard Haskell library that is always available) are: Int / Integer Float Char String Bool Just to be sure lets recap those data types, in Haskell it is very important to have a good understanding of types. Int / Integer refer to whole numbers the only difference is the bounds of the number, the maximum and minimum it can be, this is due to memory allocation. The Int supports integers in the range [-2^29 … 2^29-1], where as Integer is an arbitrary precision type, it can hold any number subject to the machines memory limitations. A Float holds a decimal value. A Char hold a single character. A String holds multiple characters, in actual fact the String data type is actually a Type Alias for [Char], a list of character, we will be using this fact later in this series. Finally Bool which is a Boolean value which is a logical result either True or False. As you discover Algebraic Data Types you will find that the above list is in fact essentially infinite, I will cover this topic in detail in a later post. ","date":"27/05/2019","objectID":"/functions/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Applying a Function Haskell gives us two ways of applying Arguments to a Function. ","date":"27/05/2019","objectID":"/functions/:3:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Prefix Application Prefix application is where the function name comes before the arguments. In Haskell to apply a function we don’t bother with round brackets. sum [1,2,3] -- sum :: Num a =\u003e [a] -\u003e a -- Returns the sum of the list max 4 19 -- max :: Ord a =\u003e a -\u003e a -\u003e a -- Returns the largest of its two arguments As you can see the function name is given before the arguments to this is a Prefix application. Note the -- above are used to give comments in a Haskell source code file. ","date":"27/05/2019","objectID":"/functions/:3:1","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Infix Application However, some functions would look strange if they was written in a Prefix style. We have another option Infix application. 1 + 2 -- (+) :: Num a =\u003e a -\u003e a -\u003e a -- Returns the sum of its arguments True \u0026\u0026 False -- (\u0026\u0026) :: Bool -\u003e Bool -\u003e Bool -- Returns the result of the application of a logical 'and' As you can see the function name is in between the arguments of the function. However, sometimes we may want to write a infix function in a prefix style this can be done very easily, by enclosing it in round brackets. (+) 1 2 -- (+) :: Num a =\u003e a -\u003e a -\u003e a -- Returns the sum of its arguments (\u0026\u0026) True False -- (\u0026\u0026) :: Bool -\u003e Bool -\u003e Bool -- Returns the result of the application of a logical 'and' We may also want to write a prefix function in a infix function in a prefix style, this can be done by enclosing the function name in back ticks `. 4 `max` 19 -- max :: Ord a =\u003e a -\u003e a -\u003e a -- Returns the largest of its two arguments ","date":"27/05/2019","objectID":"/functions/:3:2","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Composing a Function Know we know how to apply a function, we want to know how we can string functions together to achieve our goal. square :: Int -\u003e Int -- Returns the square of a number cube :: Int -\u003e Int -- Returns the cube of a number largest :: Int -\u003e Int -\u003e Int -- Returns the largest of two numbers (cube 2) `largest` (square 3) In the example above we have used largest in an infix style, because to me that makes the code easier to understand, both cube and square have both been used prefix because again that style makes the code easier to read in this situation. The largest function has been composed with both cube and square the result of those calculations are given to the largest function (and evaluated when required, Haskell is lazy. ","date":"27/05/2019","objectID":"/functions/:4:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Defining a new Function Right enough reading, I think its about time we wrote some Haskell for ourselves. Open your favourite text editor, I like to use Emacs I will be making a series about Emacs soon. Create a file called basic_functions.hs all Haskell source code files will have the .hs file extension. Lets now define the square, cube and largest functions. We are using Haskell so Types Matter, although the Haskell Type System can infer types I always give a Type Signature for every function I define. square :: Int -\u003e Int Now its time for the actual function, what we need the function to do is get a value and return its square. Lets use the power operator (^). square :: Int -\u003e Int square x = x^2 That’s it, our first Haskell function, write the cube function then check your answer. cube :: Int -\u003e Int cube = (^3) Have you got the same? This is a new concept I have not introduced yet. This feature of Haskell is called Partial Function Application, its allows us to simplify the definition of functions, to essentially their logical/base components. Don’t you :heart: Haskell. The largest function behaves identically to the max function, so why not use that. largest :: Int -\u003e Int -\u003e Int largest = max The above is just example, in any other situation you might as well us the prelude function max and avoid unnecessary definitions Its time to test our new functions, open your favourite terminal emulator, move to the directory where the Haskell source code file is stored and enter ghci basic_functions.hs, this will load the file in to the Glasgow Haskell Compiler Interactive. Now from the GHCI prompt, enter cube 4 you should see the result 64 displayed directly in the terminal windows Enter square 9 you should see the result 81. Congratulations, you’ve just written your first Haskell code. I hope you’ve picked up some ideas about functions now, we will be building on these on later posts. The next post will be about a very cool Haskell feature Lists and Comprehensions, see you there. ","date":"27/05/2019","objectID":"/functions/:5:0","tags":["Programming","Tutorial","Haskell"],"title":"Functions","uri":"/functions/"},{"categories":["Haskell for Beginners"],"content":"Welcome back to the next post now we will be learning about List and comprehensions, they form a large part of a typical Haskell program, so lets find out more about them now. ","date":"28/05/2019","objectID":"/lists-and-comprehensions/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Comprehensions","uri":"/lists-and-comprehensions/"},{"categories":["Haskell for Beginners"],"content":"The List nums :: [Int] nums = [1,2,3] chars :: [Char] chars = ['h', 'a', 's', 'k', 'e', 'l', 'l'] str :: String str = \"haskell\" funcs :: [[Int] -\u003e Int] funcs = [product, sum] evenList :: [Int] evenList = [0,2..100] Haskell loves lists! Due to the Type System, all list can only contain elements of the same type. Haskell also allows for infinite lists. An example of this can be seen below, I have extended the definition above to include all the even numbers - cool right! However, when we use infinite lists we have to ensure that we write robust code, so that we know our programs will eventually terminate. This will become even more important when we talk about recursion. evenList :: [Int] evenList = [0,2..] ## Basic List Operations Now we know about the list, lets look into some basic functions that can be applied to a list. This list shows us some of the most common functions, that are typically used with a List Comprehension product - returns the product of all the numbers in a list sum - returns the sum of all the numbers in a list and - applied a logic ‘and’ to the values in a list and returns the result or - applied a logic ‘or’ to the values in a list and returns the result !! - the infix direct access operator, returns the element at the nth position of the list Plus a lot more. Check out Hoogle, for a list of functions. Now lets see some examples of how these functions are used. product [1,2,3,4,5] will return the value of 1*2*3*4*5 which is 120. sum [1,2,3,4,5] will return the value of 1+2+3+4+5 which is 15. and [True,True,False,False,True] will return the value of True \u0026\u0026 True \u0026\u0026 False \u0026\u0026 False \u0026\u0026 True which is False. Since there exists a False within the list. or [True,True,False,False,True] will return the value of True || True || False || False || True which is True. Since there exist a True within the list. [0,2..100] !! 10 will return the element of the list [0,2..10] that is in the 10th position. Warning , remember that list in Haskell and most programming languages are Zero Indexed, we start counting from zero not one. ","date":"28/05/2019","objectID":"/lists-and-comprehensions/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Comprehensions","uri":"/lists-and-comprehensions/"},{"categories":["Haskell for Beginners"],"content":"List Comprehensions Now we have the background knowledge its time we learn some List Comprehensions I like to think of a list comprehension in exactly the same way I think about Set Notation from mathematics. I’m going to show the various part that make up a list comprehension. [x | x \u003c- [1..10], odd x] -- [x | This part of the list comprehension shows us what -- is added to the resulting list for each element -- of the generating list. -- x \u003c- [1..10] This part of the list comprehension -- is called the generator. It gets -- the elements from the generating -- list. -- \u003c- This is the 'drawn from' operator. -- , odd x] This final part of is known -- as the guard, it almost like -- an if statement. The element -- is added only if this is true. The above may look complicated but that is more of the formal introduction to List Comprehensions. ","date":"28/05/2019","objectID":"/lists-and-comprehensions/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Comprehensions","uri":"/lists-and-comprehensions/"},{"categories":["Haskell for Beginners"],"content":"Examples Now lets run through some examples. I may introduce some more exciting functions as we go along. I will also take you through my thought process as I come up with a solution. Create a list comprehension that gives us all of the positive even numbers. So the answer needs to choose only the even numbers, so we will be needing a guard for even numbers. We will have to use the even function. Lets find out more info about the even function. Open ghci as you have done previously Enter :info even this can also be shortened to :i even. Take note of the type, we give it an Integral which is either a Int or Integer and it returns a Bool This is exactly what we want, so lets use this handy function. We want all of the positive even numbers so we are going to have to use an infinite list. This is the generator. We don’t need to apply any function to the number that is added from the generator. So the final List Comprehension becomes the one below. [x | x \u003c- [0,2..], even x] Create a list of the first 100 perfect squares. When creating this list we can either, check if a number is a perfect square using a guard then add it, or create the perfect squares ourselves. I personally think the latter is easier. So we won’t be needing any guards for this solution. The generator should give us all of the first 100 integers so that we can make them into the perfect squares. We will need to apply a functions to each of the values, we need to square them. So the final List Comprehension becomes the one below. [x^2 | x\u003c-[1..100]] Find the product of the first 100 perfect squares This problem would be very complicated to solve without the aid of a computer. We will be composing a previous solution with one of the list functions we introduced earlier in this post. We already have list of the first 100 perfect squares, now we need to get the product of all of them. Lets get more info about the product function Lets open ghci Enter :i product Note the function takes a list of numbers and returns a single number This is exactly what we want, lets use the product function So the final List Comprehension becomes the one below. product [x^2 | x\u003c-[1..100]] Define a function that takes a String argument and returns a String containing only the letters of the input but now all lowercase. From one of my previous post I said a String is a Type Alias for [Char]. We are going to have to use this fact to answer this question. We have to only add characters that are letters so we are going to have to use a guard. Lets find out more info about the isLetter function. As previously use ghci to get more information about the function We can see that the function takes a Char and returns a Bool this is perfect for what we want We are given a string so that must form part of the generator Finally we must make all of the characters lowercase, so we must apply a function to each of them. Lets look at the toLower function Again use ghci to get more info We see that the function takes a Char and returns a Char this is what we want So the final list comprehension becomes f :: String -\u003e String f xs = [toLower x | x\u003c-xs, isLetter x] The above is a more complex example, lets go through the main parts of it again for clarity. For this problem we have defined a function f that takes a String as input and returns a String. The input string is the xs on the left hand side of the assignment operator =. We go through each element of xs which has type [Char], we call this element x. First we check if it is a letter, if False it is discarded, if True we apply the toLower function, making it lowercase then add it to the list to be returned. ","date":"28/05/2019","objectID":"/lists-and-comprehensions/:3:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Comprehensions","uri":"/lists-and-comprehensions/"},{"categories":["Haskell for Beginners"],"content":"Conclusion I hope this post has been beneficial. There are many situations in which list comprehension can massively simplify problems that you will face so always keep them in mind. In the next post I will be covering Lists and Recursion. Kyle out! ","date":"28/05/2019","objectID":"/lists-and-comprehensions/:4:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Comprehensions","uri":"/lists-and-comprehensions/"},{"categories":["Haskell for Beginners"],"content":"Our research into Haskell Lists continues. Before we can look into using recursive functions with lists, I think first we need to cover what recursion is. In my opinion recursion is one of the most important concepts for any Functional Programmer. Recursion: Where a function calls its self from within its definition. Case: A condition that could happen, eg the number could be zero or it may not be. Lets kick off with an example of a recursive example then I’ll work through it with you. Keep in mind the definitions of recursion and a case from above. factoralRec :: Int -\u003e Int factoralRec 0 = 1 factoralRec x = x * factoralRec (x-1) {------------------------------------------ How the lazy evaluation occurs: factoralRec 4 4 * factoralRec (4-1) 4 * factoralRec 3 4 * 3 * factoralRec (3-1) 4 * 3 * factoralRec 2 4 * 3 * 2 * factoralRec (2-1) 4 * 3 * 2 * factoralRec 1 4 * 3 * 2 * 1 * factoralRec (1-1) 4 * 3 * 2 * 1 * factoralRec 0 4 * 3 * 2 * 1 * 1 24 ------------------------------------------} Above we have an example of using recursion to find the factorial of a number. I have also added a multi-line comment (using the {-COMMENT-} syntax) to show how the lazy evaluation of an expression occurs in Haskell. ","date":"29/05/2019","objectID":"/recursion/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Recursion","uri":"/recursion/"},{"categories":["Haskell for Beginners"],"content":"Base Case The base case is the most important aspect of any recursive function, this is where the recursion ends (the program doesn’t call its self in this case). We are always computing to get to the base case, in the above example, we are decreasing the number that is passed in the the factoralRec function by one each time. We then reach the Base Case factoralRec 0 = 1 - this is where the recursive calls stop and the program can begin to unwind, the theory behind recursion can be quite complex for a beginner but read here for more information. ","date":"29/05/2019","objectID":"/recursion/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Recursion","uri":"/recursion/"},{"categories":["Haskell for Beginners"],"content":"Recursive Call Alas, we may have the best base case but any recursive function still needs a recursive call, the is where the function calls it self. You can see this in the line factoralRec x = x * factoralRec (x-1), this may seem complicated at first. I was also initially confused, I used to ask myself, ‘how does the compiler know what the function is if its used in its own the definition?'. After the code I have shown how the evaluation would occur, I have omitted some brackets to make it easier to understand, as the bracketing doesn’t matter with this function. I hope this makes the recursive step easier to understand. ","date":"29/05/2019","objectID":"/recursion/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Recursion","uri":"/recursion/"},{"categories":["Haskell for Beginners"],"content":"Conclusion This has been a quick and dirty introduction to Recursion, in the next post I will be covering how we can use this new knowledge with particular applications to list. ","date":"29/05/2019","objectID":"/recursion/:3:0","tags":["Programming","Tutorial","Haskell"],"title":"Recursion","uri":"/recursion/"},{"categories":["Haskell for Beginners"],"content":"Now you know a little about Recursion its time we use this knowledge for good - lets use it with a Haskell Favorite, Lists! ","date":"30/05/2019","objectID":"/lists-and-recursion/:0:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Recursion","uri":"/lists-and-recursion/"},{"categories":["Haskell for Beginners"],"content":"How the list is built I’ve spoken about the List Data Type previously in the Haskell for Beginners: Lists and Comprehensions post, but we need to know a little more about them before we can apply our newly found recursive knowledge to them. A list is build not made, let me explain. Every list is build using only :, ‘cons’ and [] the empty list. -- Note: This is not valid Haskell code -- only the representations as -- lists are accurate. [1,2,3] = 1:(2:(3:[])) \"list\" = [’l’,’i’,’s’,’t’] = ’l’:(’i’:(’s’:(’t’:[]))) The above may look complicated, but lets go through it. A very important thing to remember for later is that the Base of any list is the Empty List []. From here we append elements onto the list using the ‘cons’ (short for construct) : operator. The Type Signature of gives a clear picture of what the operator does (:) :: a -\u003e [a] -\u003e [a], if your unsure how to interpret this signature check out the Haskell for Beginners: Understanding Haskell Documentation post, which covers this in detail. ","date":"30/05/2019","objectID":"/lists-and-recursion/:1:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Recursion","uri":"/lists-and-recursion/"},{"categories":["Haskell for Beginners"],"content":"Pattern Matching The last thing we need to know is pattern matching, this allows us to split a list if it matches a pattern, lets look at an example to make things easier to understand. patternMatch :: [a] -\u003e String patternMatch (_:_:_) = \"List with at least 2 elements\" patternMatch (_:_) = \"Non-Empty List\" patternMatch [] = \"Empty List\" Above we have a nice example of pattern matching in action. Note, the _ character matches with anything, we use this if we don’t care what the actual value is, it allows for compiler optimization. I’ll give an example using the values from a pattern match a little later. Let me now go through each pattern and describe what it means. [] - Use this statement if the input is the empty list. (_:_) - Use this statement if there is at least one element in the list. This is because the final _ may be the empty list, but it may contain any number of elements or it could even be infinite. (_:_:_) - This pattern is very similar to the one above, but it allows us to say this list contains at least two elements. We can pattern match any finite number of elements from a list (if you want to type out the pattern :-) ). I advise you copy and play about with this example, you will notice that the order of the expressions does indeed matter. Haskell will use the first available pattern that matches so if we swapped lines two and three, then this statement patternMatch (_:_:_) = \"List with Two+ Elements\" would be redundant. Note, we are using a Polymorphic Type, ‘a', we will be covering this when we go through Type Classes. Note, the last line patternMatch [] = \"Empty List\", is not strictly a pattern match, but it is required. If you omit that line and then try to evaluate, patternMatch [] you will get an error, Exception: Non-exhaustive patterns in function patternMatch. This means there is a case that we have not considered, so when Haskell trys to replace it, it doesn’t know what to replace it with and has no choice but to raise an exception. As you will find out, if you program in a correct functional way run time errors will be extremely rare. Pattern matching can also be used to extract elements from a list, lets run through a quick example of how this would work. patternMatch :: (Show a) =\u003e [a] -\u003e String patternMatch (x1:x2:xs) = \"First Element: \" ++ show x1 ++ \" Second Element: \" ++ show x2 ++ \" Rest of the List: \" ++ show xs patternMatch (x:xs) = \"First Element: \" ++ show x ++ \" Rest of the List: \" ++ show xs patternMatch [] = \"Empty List\" The biggest change in this version of the code in terms of the pattern matching is that we have now name the elements of the pattern, where before we used _ now we have used variables, x1,~x2~,~x~,~xs~ in this particular example. This allows us to extract elements from the list. In the above example I have used a new function show, so lets go through it. class Show a where ... show :: a -\u003e String ... -- Defined in ‘GHC.Show’ Using ghci we get the following info, you know how to read this from the Haskell for Beginners: Understanding Haskell Documentation post. The function takes an input of any type (that can be showed, this related to Type Classes which we are discussing later), and returns a String version of it. Here are some example of show: Prelude\u003e show 4 \"4\" Prelude\u003e show True \"True\" Prelude\u003e show [1,2,3] \"[1,2,3]\" The ++ operator just combines two lists returning a new list. ","date":"30/05/2019","objectID":"/lists-and-recursion/:2:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Recursion","uri":"/lists-and-recursion/"},{"categories":["Haskell for Beginners"],"content":"Examples Now we’ve got the background knowledge, lets run through some examples. I may introduce some more exciting functions as we go along. I will also take you through my thought process as I come up with a solution. Create a recursive function list that gives us all of the positive even numbers from a list. When creating a recursive function, we first need to think about the base case. In this example that is the empty list, when the empty list is input the empty list should be returned. Now we need to think about the recursive step, we have to select only the even numbers so we will have to use a guard, this will be done in conjunction with a pattern match If the number is a even number it must be added to the list. We must continue checking the rest of the list till we reach the empty list the base case. If the number is odd we ignore it and continue with the rest of the list. So the final function could be something like below. When we use guards in functions they are represented with a pipe |, the otherwise statement will always be used if none of the above cases are met. You don’t have to use the otherwise however, I heavily recommend it since it will avoid the dreaded Exception: Non-exhaustive patterns in function evenList error. evenList :: [Int] -\u003e [Int] evenList [] = [] evenList (x:xs) | even x = x : evenList xs | otherwise = evenList xs Create a function that returns the square of all of the elements in a list. First we always consider the base case. Again this will be the empty list, which will just return the empty list. Now we think about the recursive step All we need to do for the recursive step is go through and square all of the elements until we reach the base case (the empty list). So the final function could look something like this. squareRec :: [Int] -\u003e [Int] squareRec [] = [] squareRec (x:xs) = x^2 : squareRec xs Find the product of the square of all the numbers in a list. This problem is slightly different, unlike the List Comprehension method where we get the list then find the product in this example it will be easier to do it all in one function. As always lets consider the base case, here when we get the empty list we must return an integer. When we get the empty list we must return 1 as this is the identity for multiplication. Just like 0 is the identity for addition. Now lets consider the recursive step. We need to get the element out of the list, we can use pattern matching to do this. We then need to square this element Then we need to multiply it my the result of the rest of the list going through the same process, this is the recursive part. So the final function could look something like this. squareProdRec :: [Int] -\u003e Int squareProdRec [] = 1 squareProdRec (x:xs) = x^2 * squareProdRec xs Define a function that takes a String argument and returns a String containing only the letters of the input but now all lowercase. From one of my previous post I said a String is a Type Alias for [Char]. We are going to have to use this fact to answer this question. We will treat the String as a list of Char, so that we can recurse over it. The first thing we need to consider is the base case this will be the empty list, inputting the empty list should return the empty list. Now the recursive step, we have two cases, the Char is a letter and it is not a letter. We will have to use guards. If the Char is a letter (isLetter returns True), then we apply the toLower function, add it to the resulting list and continue with the rest of the list until we reach the empty list, out base case. If the isLetter returns False we ignore it and continue with the rest of the list. So the final function becomes import Data.Char lowerLetterRec :: String -\u003e String lowerLetterRec [] = [] lowerLetterRec (x:xs) | isLetter x = toLower x : lowerLetterRec xs | otherwise = lowerLetterRec xs ","date":"30/05/2019","objectID":"/lists-and-recursion/:3:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Recursion","uri":"/lists-and-recursion/"},{"categories":["Haskell for Beginners"],"content":"Conclusion Well there you have it another way of messing with lists. Isn’t recursion in Haskell great! In the next post we will be covering one of my favorite topics, Haskell for Beginners: High Order Functions. See you in the next post, Kyle out! ","date":"30/05/2019","objectID":"/lists-and-recursion/:4:0","tags":["Programming","Tutorial","Haskell"],"title":"Lists and Recursion","uri":"/lists-and-recursion/"}]