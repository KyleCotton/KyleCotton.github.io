#+hugo_base_dir: .
#+hugo_section: ./posts
#+org-hugo-footer: ""
#+hugo_weight: auto
#+hugo_front_matter_format: yaml
#+hugo_auto_set_lastmod: t
#+author:

* Haskell for Beginners :Programming:Tutorial:@Haskell__for__Beginners:Haskell:
** DONE An Introduction to Haskell
:PROPERTIES:
:EXPORT_FILE_NAME: An-Introduction-to-Haskell.md
:EXPORT_DATE: 2019-05-24
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

Welcome to my first post in a series on Haskell. In this series I will be covering a range of beginner topics; the series may continue to me covering more advanced topics.
** DONE Installing Haskell
:PROPERTIES:
:EXPORT_FILE_NAME: Installing-Haskell.md
:EXPORT_DATE: 2019-05-25
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

In this episode we will be installing Haskell, a lot of people struggle to install software to their machine and each operating system will be different, generally I advise the use of a package manger - not just to install Haskell, but to  install all software. I will be making a post about [[https://brew.sh/][Brew]] at some point which makes this process trivial.
*** MacOS

MacOS my operating system of choice, to install Haskell on a MacOS system, the best method is to use a package manager such as [[https://brew.sh/][Brew]].

1.  If you don't have [[https://brew.sh/][Brew]] installed, follow the link and install that. Brew is one of my essential utilities for any new Mac.
2.  Open your favourite terminal emulator such as ~Terminal.app~, pre-installed on all Macs.
3.  From your command line run, ~brew install ghc~, this will install the latest version of the _Glasgow Haskell Compiler_
4.  Happy Days! Haskell is now installed.
*** Linux

1.  Open your favourite terminal emulator such as ~Terminal~.
2.  Using your favourite package manager install ~ghc~, this will install the latest version of the _Glasgow Haskell Compiler_
3.  Happy Days! Haskell is now installed.
*** Windows
A lot of software we use in Computer Science does run on Windows, but it does not play nice, lets fix that.

1. If your don't have [[https://docs.microsoft.com/en-us/windows/wsl/install-win10][WSL (Windows Subsystem for Linux)]], go install that first
2. Congratulations, your avoiding Windows, now follow the Linux instructions.
** DONE Understanding Haskell Documentation
:PROPERTIES:
:EXPORT_FILE_NAME: Understanding-Haskell-Documentation.md
:EXPORT_DATE: 2019-05-26
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

In this post I will be giving an insight in reading haskell documentation
*** Product Example
#+BEGIN_SRC haskell
product :: Num a => [a] -> a
-- The product function computes the product of a finite list of numbers.
#+END_SRC

Above is an extract from the Haskell documentation.

Line 1 shows the **Type Signature** of the product function, this shows the types of the inputs and the outputs in a convenient way.

All functions in Haskell return a single object, this could be a single number, tuple, list etc. The first part of this statement ~Num a~ is called a **Type Class** this is a more advanced topic and something we will discuss later.

The final part of the statement ~[a] -> a~ this  is showing a list of something is given to the ~product~ function and a single something is returned. The type of the something must be a ~Num~ as it is stated in the **Type Class**.
*** Appending Two Lists
#+BEGIN_SRC haskell
(++) :: [a] -> [a] -> [a]
-- Append two lists
#+END_SRC

Above is an extract from the Haskell documentation.

Again line 1 shows the **Type Signature** of the append operator. We know haskell returns only a single object so we know what the final ~[a]~ represents that means that the first two ~[a]~ must be the inputs to the function. So this function takes two lists of the same type (both are parameterised with a) and  returns a new list  of the same type of the input.
** DONE Functions
:PROPERTIES:
:EXPORT_FILE_NAME: Functions.md
:EXPORT_DATE: 2019-05-27
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

Functions, functions, functions; Haskell is all about functions.
When writing Haskell code we create, compose and apply functions to achieve our goal.


*** What is a function
In Haskell a function takes one or more things (referred to as arguments), and will give you back something else (referred to as the output or return value).

So to recap, a Haskell function takes something and gives something else back. This is all a 'normal' function can do in Haskell, I will discuss the 'non-normal' functions, ones that can effect the program state later, they are more advanced.

*** Kinds of Data
So we know what a function is, so what can I give it. In other words what types can the function accept.

Some commonly used data types defined in ~prelude~ (the standard Haskell library that is always available) are:
- ~Int~ / ~Integer~
- ~Float~
- ~Char~
- ~String~
- ~Bool~

Just to be sure lets recap those data types, in Haskell it is very important to have a good understanding of types.

~Int~ / ~Integer~ refer to whole numbers the only difference is the bounds of the number, the maximum and minimum it can be, this is due to memory allocation. The ~Int~ supports integers in the range [-2^29 ... 2^29-1], where as ~Integer~ is an arbitrary precision type, it can hold any number subject to the machines memory limitations.

A ~Float~ holds a decimal value.

A ~Char~ hold a single character.

A ~String~ holds multiple characters, in actual fact the ~String~ data type is actually a _Type Alias_ for ~[Char]~, a list of character, we will be using this fact later in this series.

Finally ~Bool~ which is a Boolean value which is a logical result either ~True~ or ~False~.

As you discover _Algebraic Data Types_ you will find that the above list is in fact essentially infinite, I will cover this topic in detail in a later post.

*** Applying a Function
Haskell gives us two ways of applying *Arguments* to a *Function*.

**** Prefix Application
*Prefix* application is where the function name comes before the arguments. In Haskell to apply a function we don't bother with round brackets.

#+BEGIN_SRC haskell
sum [1,2,3]
-- sum ::  Num a => [a] -> a
-- Returns the sum of the list

max 4 19
-- max :: Ord a => a -> a -> a
-- Returns the largest of its two arguments
#+END_SRC

As you can see the function name is given before the arguments to this is a _Prefix_ application. Note the ~--~ above are used to give comments in a Haskell source code file.

**** Infix Application
However, some functions would look strange if they was written in a _Prefix_ style. We have another option *Infix* application.

#+BEGIN_SRC haskell
1 + 2
-- (+) :: Num a => a -> a -> a
-- Returns the sum of its arguments

True && False
-- (&&) :: Bool -> Bool -> Bool
-- Returns the result of the application of a logical 'and'
#+END_SRC

As you can see the function name is in between the arguments of the function.

However, sometimes we may want to write a infix function in a prefix style this can be done very easily, by enclosing it in round brackets.
#+BEGIN_SRC haskell
(+) 1 2
-- (+) :: Num a => a -> a -> a
-- Returns the sum of its arguments

(&&) True False
-- (&&) :: Bool -> Bool -> Bool
-- Returns the result of the application of a logical 'and'
#+END_SRC

We may also want to write a prefix function in a infix function in a prefix style, this can be done by enclosing the function name in _back ticks_ ~`~.
#+BEGIN_SRC haskell
4 `max` 19
-- max :: Ord a => a -> a -> a
-- Returns the largest of its two arguments
#+END_SRC

*** Composing a Function
Know we know how to apply a function, we want to know how we can string functions together to achieve our goal.
#+BEGIN_SRC haskell
square  :: Int -> Int
-- Returns the square of a number

cube    :: Int -> Int
-- Returns the cube of a number

largest :: Int -> Int -> Int
-- Returns the largest of two numbers

(cube 2) `largest` (square 3)
#+END_SRC

In the example above we have used ~largest~ in an infix style, because to me that makes the code easier to understand, both ~cube~ and ~square~ have both been used prefix because again that style makes the code easier to read in this situation.

The ~largest~ function has been composed with both ~cube~ and ~square~ the result of those calculations are given to the ~largest~ function (and evaluated when required, Haskell is [[https://en.wikipedia.org/wiki/Lazy_evaluation][lazy]].

*** Defining a new Function
Right enough reading, I think its about time we wrote some Haskell for ourselves.

1. Open your favourite text editor, I like to use *Emacs* I will be making a series about Emacs soon.
2. Create a file called ~basic_functions.hs~ all Haskell source code files will have the ~.hs~ file extension.
3. Lets now define the ~square~, ~cube~ and ~largest~ functions.
4. We are using Haskell so *Types Matter*, although the *Haskell Type System can infer types* I always give a *Type Signature* for every function I define.
#+BEGIN_SRC haskell
square :: Int -> Int
#+END_SRC
5. Now its time for the actual function, what we need the function to do is get a value and return its square. Lets use the power operator ~(^)~.
#+BEGIN_SRC haskell
square :: Int -> Int
square x = x^2
#+END_SRC
6. That's it, our first Haskell function, write the cube function then check your answer.
#+BEGIN_SRC haskell
cube :: Int -> Int
cube = (^3)
#+END_SRC
7. Have you got the same? This is a new concept I have not introduced yet. This feature of Haskell is called *Partial Function Application*, its allows us to simplify the definition of functions, to essentially their logical/base components. Don't you :heart: Haskell.
8. The ~largest~ function behaves identically to the ~max~ function, so why not use that.
#+BEGIN_SRC haskell
largest :: Int -> Int -> Int
largest = max
#+END_SRC
9. The above is just example, in any other situation you might as well us the ~prelude~ function ~max~ and avoid  unnecessary definitions
10. Its time to test our new functions, open your favourite terminal emulator, move to the directory where the Haskell source code file is stored and enter ~ghci basic_functions.hs~, this will load the file in to the _Glasgow Haskell Compiler Interactive_.
11. Now from the GHCI prompt, enter ~cube 4~ you should see the result ~64~ displayed directly in the terminal windows
12. Enter ~square 9~ you should see the result ~81~.
13. Congratulations, you've just written your first Haskell code.


# Conclusion
I hope you've picked up some ideas about functions now, we will be building on these on later posts. The next post will be about a very cool Haskell feature _Lists and Comprehensions_, see you there.

** DONE Lists and Comprehensions
:PROPERTIES:
:EXPORT_FILE_NAME: Lists-and-Comprehensions.md
:EXPORT_DATE: 2019-05-28
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:
Welcome back to the next post now we will be learning about _List and comprehensions_, they form a large part of a typical Haskell program, so lets find out more about them now.

*** The List
#+BEGIN_SRC haskell
nums :: [Int]
nums = [1,2,3]

chars  :: [Char]
chars  =  ['h', 'a', 's', 'k', 'e', 'l', 'l']

str  :: String
str  =  "haskell"

funcs :: [[Int] -> Int]
funcs = [product, sum]

evenList :: [Int]
evenList = [0,2..100]
#+END_SRC

Haskell loves lists! Due to the _Type System_, all list can only contain elements of the same type.

Haskell also allows for infinite lists. An example of this can be seen below, I have extended the definition above to include all the even numbers - cool right! However, when we use infinite lists we have to ensure that we write robust code, so that we know our programs will eventually terminate. This will become even more important when we talk about recursion.
#+BEGIN_SRC haskell
evenList :: [Int]
evenList = [0,2..]
#+END_SRC

## Basic List Operations
Now we know about the list, lets look into some basic functions that can be applied to a list.
This list shows us some of the most common functions, that are typically used with a _List Comprehension_
- ~product~ - returns the product of all the numbers in a list
- ~sum~ - returns the sum of all the numbers in a list
- ~and~ - applied a logic 'and' to the values in a list and returns the result
- ~or~ - applied a logic 'or' to the values in a list and returns the result
- ~!!~ - the infix direct access operator, returns the element at the nth position of the list
- Plus a lot more. Check out [[https://hoogle.haskell.org/][Hoogle]], for a list of functions.

Now lets see some examples of how these functions are used.

~product [1,2,3,4,5]~ will return the value of ~1*2*3*4*5~ which is ~120~.

~sum [1,2,3,4,5]~ will return the value of ~1+2+3+4+5~ which is ~15~.

~and [True,True,False,False,True]~ will return the value of ~True && True && False && False && True~ which is ~False~. Since there exists a ~False~ within the list.

~or [True,True,False,False,True]~ will return the value of ~True || True || False || False || True~ which is ~True~. Since there exist a ~True~ within the list.

~[0,2..100] !! 10~ will return the element of the list ~[0,2..10]~ that is in the 10th position. **Warning** , remember that list in Haskell and  most programming languages are **Zero Indexed**, we start counting from zero not one.


*** List Comprehensions

Now we have the background knowledge its time we learn some *List Comprehensions*

I like to think of a list comprehension in exactly the same way I think about _Set Notation_ from mathematics.
I'm going to show the various part that make up a list comprehension.

#+BEGIN_SRC haskell
[x | x <- [1..10], odd x]

-- [x | This part of the list comprehension shows us what
--      is added to the resulting list for each element
--      of the generating list.

--      x <- [1..10] This part of the list comprehension
--                   is called the generator. It gets
--                   the elements from the generating
--                   list.

--        <- This is the 'drawn from' operator.

--               , odd x] This final part of is known
--                            as the guard, it almost like
--                            an if statement. The element
--                            is added only if this is true.
#+END_SRC

The above may look complicated but that is more of the formal introduction to *List Comprehensions*.

*** Examples
Now lets run through some examples. I may introduce some more exciting functions as we go along.
I will also take you through my thought process as I come up with a solution.

- Create a list comprehension that gives us all of the positive even numbers.
  - So the answer needs to choose only the even numbers, so we will be needing a guard for even numbers. We will have to use the ~even~ function.
    - Lets find out more *info* about the even function.
    - Open ~ghci~ as you have done previously
    - Enter ~:info even~ this can also be shortened to ~:i even~.
    - Take note of the type, we give it an ~Integral~ which is either a ~Int~ or ~Integer~ and it returns a ~Bool~
    - This is exactly what we want, so lets use this handy function.
  - We want **all** of the positive even numbers so we are going to have to use an infinite list. This is the generator.
  - We don't need to apply any function to the number that is added from the generator.
  - So the final List Comprehension becomes the one below.

#+BEGIN_SRC haskell
[x | x <- [0,2..], even x]
#+END_SRC

- Create a list of the first 100 perfect squares.
  - When creating this list we can either, check if a number is a perfect square using a guard then add it, or create the perfect squares ourselves. I personally think the latter is easier.
  - So we won't be needing any guards for this solution.
  - The generator should give us all of the first 100 integers so that we can make them into the perfect squares.
  - We will need to apply a functions to each of the values, we need to square them.
  - So the final List Comprehension becomes the one below.

#+BEGIN_SRC haskell
[x^2 | x<-[1..100]]
#+END_SRC

- Find the product of the first 100 perfect squares
  - This problem would be very complicated to solve without the aid of a computer.
  - We will be composing a previous solution with one of the list functions we introduced earlier in this post.
  - We already have list of the first 100 perfect squares, now we need to get the product of all of them.
  - Lets get more *info* about the ~product~ function
    - Lets open ~ghci~
    - Enter ~:i product~
    - Note the function takes a list of numbers and returns a single number
    - This is exactly what we want, lets use the product function
  - So the final List Comprehension becomes the one below.

#+BEGIN_SRC haskell
product [x^2 | x<-[1..100]]
#+END_SRC

- Define a function that takes a ~String~ argument and returns a ~String~ containing only the letters of the input but now all lowercase.
  - From one of my previous post I said a ~String~ is a *Type Alias* for ~[Char]~. We are going to have to use this fact to answer this question.
  - We have to only add characters that  are letters so we are going to have to use a guard. Lets find out more *info* about the ~isLetter~ function.
    - As previously use ~ghci~ to get more information about the function
    - We can see that the function takes a ~Char~ and returns a ~Bool~ this is perfect for what we want
   - We are given a string so that must form part of the generator
   - Finally we must make all of the characters lowercase, so we must apply a function to each of them. Lets look at the ~toLower~ function
     - Again use ~ghci~ to get more *info*
     - We see that the function takes a ~Char~ and returns a ~Char~ this is what we want
    - So the final list comprehension becomes

#+BEGIN_SRC haskell
f :: String -> String
f xs = [toLower x | x<-xs, isLetter x]
#+END_SRC

The above is a more complex example, lets go through the main parts of it again for clarity.

For this problem we have defined a function ~f~ that takes a ~String~ as input and returns a ~String~.
The input string is the ~xs~ on the left hand side of the _assignment operator ~=~_.
We go through each element of ~xs~ which has type ~[Char]~, we call this element ~x~.
First we check if it is a letter, if ~False~ it is discarded, if ~True~ we apply the ~toLower~ function, making it lowercase then add it to the list to  be returned.

*** Conclusion
I hope this post has been beneficial. There are many situations in which list comprehension can massively simplify problems that you will face so always keep them in mind. In the next post I will be covering Lists and Recursion. Kyle out!
** DONE Recursion
:PROPERTIES:
:EXPORT_FILE_NAME: Recursion.md
:EXPORT_DATE: 2019-05-29
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:END:

Our research into _Haskell  Lists_ continues.
Before we can look into using recursive functions with lists, I think first we need to cover what recursion is.
In my opinion recursion is one of the most important concepts for any _Functional Programmer_.

#+begin_quote
Recursion: Where a function calls its self from within its definition.
#+end_quote

#+begin_quote
Case: A condition that could happen, eg the number could be zero or it may not be.
#+end_quote

Lets kick off with an example of a recursive example then I'll work through it with you. Keep in mind the definitions of *recursion* and a *case* from above.

#+BEGIN_SRC haskell
factoralRec :: Int -> Int
factoralRec 0 = 1
factoralRec x = x * factoralRec (x-1)

{------------------------------------------
How the lazy evaluation occurs:
factoralRec 4
4 * factoralRec (4-1)
4 * factoralRec 3
4 * 3 * factoralRec (3-1)
4 * 3 * factoralRec 2
4 * 3 * 2 * factoralRec (2-1)
4 * 3 * 2 * factoralRec 1
4 * 3 * 2 * 1 * factoralRec (1-1)
4 * 3 * 2 * 1 * factoralRec 0
4 * 3 * 2 * 1 * 1
24
------------------------------------------}
#+END_SRC

Above we have an example of using recursion to find the factorial of a number. I have also added a *multi-line comment* (using the ~{-COMMENT-}~ syntax) to show how the *lazy evaluation* of an expression occurs in Haskell.

*** Base Case
The base case is the most important aspect of any recursive function, this is where the recursion ends (the program doesn't call its self in this case).
We are always computing to get to the base case, in the above example, we are decreasing the number that is passed in the the ~factoralRec~ function by one each time.
We then reach the *Base Case* ~factoralRec 0 = 1~ - this is where the recursive calls stop and the program can begin to *unwind*, the theory behind recursion can be quite complex for a beginner but read [[https://en.wikipedia.org/wiki/Recursion_(computer_science)][here]] for more information.

*** Recursive Call
Alas,  we may have the best base case but any _recursive_ function still needs a *recursive call*, the is where the function calls it self.
You can see this in the line ~factoralRec x = x * factoralRec (x-1)~, this may seem complicated at first.
I was also initially confused, I used to ask myself, '/how does the compiler know what the function is if its used in its own the definition?/'.

After the code I have shown how the evaluation would occur, I have omitted some brackets to make it easier to understand, as the bracketing doesn't matter with this function.
I hope this makes the recursive step easier to understand.

*** Conclusion
This has been a _quick and dirty_ introduction to _Recursion_, in the next post I will be covering how we can use this new knowledge with particular applications to list.
* Misc Posts
* Pages
** About                                                              :Meta:
:PROPERTIES:
:EXPORT_FILE_NAME: about.md
:EXPORT_DATE: 2020-05-12
:EXPORT_HUGO_CUSTOM_FRONT_MATTER:
:EXPORT_HUGO_MENU: :menu "main" :weight 50
:END:
#+begin_src yaml :front_matter_extra t
hiddenFromHomePage: true
comment:
  enable: false
toc:
  enable: false
share:
  enable: false
#+end_src

*** About
Hi I'm Kyle Cotton a third year Computer Science student at the University of Edinburgh. I'm personally interested in Computer & Network Security.
*** Contact
Here are the ways you can get in touch with me I prefer email though.
- Lets talk code [[https://github.com/KyleCotton][GitHub]]
- Shoot me an [[mailto:kylecottonkc@gmail.com][Email]]
- Lets IM over [[https://t.me/KyleCotton][Telegram]]
