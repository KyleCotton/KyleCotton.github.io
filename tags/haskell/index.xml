<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Haskell - Tag - Kyle Cotton</title>
        <link>https://kylecotton.github.io/tags/haskell/</link>
        <description>Haskell - Tag - Kyle Cotton</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>kylecottonkc@gmail.com (Kyle Cotton)</managingEditor>
            <webMaster>kylecottonkc@gmail.com (Kyle Cotton)</webMaster><lastBuildDate>Fri, 31 May 2019 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://kylecotton.github.io/tags/haskell/" rel="self" type="application/rss+xml" /><item>
    <title>An Introduction to Haskell</title>
    <link>https://kylecotton.github.io/an-introduction-to-haskell/</link>
    <pubDate>Fri, 24 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/an-introduction-to-haskell/</guid>
    <description><![CDATA[<p>Welcome to my first post in a series on Haskell. In this series I will be covering a range of beginner topics; the series may continue to me covering more advanced topics.</p>
]]></description>
</item><item>
    <title>Installing Haskell</title>
    <link>https://kylecotton.github.io/installing-haskell/</link>
    <pubDate>Sat, 25 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/installing-haskell/</guid>
    <description><![CDATA[<p>In this episode we will be installing Haskell, a lot of people struggle to install software to their machine and each operating system will be different, generally I advise the use of a package manger - not just to install Haskell, but to  install all software. I will be making a post about <a href="https://brew.sh/" target="_blank" rel="noopener noreffer">Brew</a> at some point which makes this process trivial.</p>
<h2 id="macos">MacOS</h2>
<p>MacOS my operating system of choice, to install Haskell on a MacOS system, the best method is to use a package manager such as <a href="https://brew.sh/" target="_blank" rel="noopener noreffer">Brew</a>.</p>
<ol>
<li>If you don&rsquo;t have <a href="https://brew.sh/" target="_blank" rel="noopener noreffer">Brew</a> installed, follow the link and install that. Brew is one of my essential utilities for any new Mac.</li>
<li>Open your favourite terminal emulator such as <code>Terminal.app</code>, pre-installed on all Macs.</li>
<li>From your command line run, <code>brew install ghc</code>, this will install the latest version of the <span class="underline">Glasgow Haskell Compiler</span></li>
<li>Happy Days! Haskell is now installed.</li>
</ol>
<h2 id="linux">Linux</h2>
<ol>
<li>Open your favourite terminal emulator such as <code>Terminal</code>.</li>
<li>Using your favourite package manager install <code>ghc</code>, this will install the latest version of the <span class="underline">Glasgow Haskell Compiler</span></li>
<li>Happy Days! Haskell is now installed.</li>
</ol>
<h2 id="windows">Windows</h2>
<p>A lot of software we use in Computer Science does run on Windows, but it does not play nice, lets fix that.</p>
<ol>
<li>If your don&rsquo;t have <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener noreffer">WSL (Windows Subsystem for Linux)</a>, go install that first</li>
<li>Congratulations, your avoiding Windows, now follow the Linux instructions.</li>
</ol>
]]></description>
</item><item>
    <title>Understanding Haskell Documentation</title>
    <link>https://kylecotton.github.io/understanding-haskell-documentation/</link>
    <pubDate>Sun, 26 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/understanding-haskell-documentation/</guid>
    <description><![CDATA[<p>In this post I will be giving an insight in reading haskell documentation</p>
<h2 id="product-example">Product Example</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">product</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="c1">-- The product function computes the product of a finite list of numbers.</span>
</code></pre></td></tr></table>
</div>
</div><p>Above is an extract from the Haskell documentation.</p>
<p>Line 1 shows the <strong><strong>Type Signature</strong></strong> of the product function, this shows the types of the inputs and the outputs in a convenient way.</p>
<p>All functions in Haskell return a single object, this could be a single number, tuple, list etc. The first part of this statement <code>Num a</code> is called a <strong><strong>Type Class</strong></strong> this is a more advanced topic and something we will discuss later.</p>
<p>The final part of the statement <code>[a] -&gt; a</code> this  is showing a list of something is given to the <code>product</code> function and a single something is returned. The type of the something must be a <code>Num</code> as it is stated in the <strong><strong>Type Class</strong></strong>.</p>
<h2 id="appending-two-lists">Appending Two Lists</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- Append two lists</span>
</code></pre></td></tr></table>
</div>
</div><p>Above is an extract from the Haskell documentation.</p>
<p>Again line 1 shows the <strong><strong>Type Signature</strong></strong> of the append operator. We know haskell returns only a single object so we know what the final <code>[a]</code> represents that means that the first two <code>[a]</code> must be the inputs to the function. So this function takes two lists of the same type (both are parameterised with a) and  returns a new list  of the same type of the input.</p>
]]></description>
</item><item>
    <title>Functions</title>
    <link>https://kylecotton.github.io/functions/</link>
    <pubDate>Mon, 27 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/functions/</guid>
    <description><![CDATA[<p>Functions, functions, functions; Haskell is all about functions.
When writing Haskell code we create, compose and apply functions to achieve our goal.</p>
<h2 id="what-is-a-function">What is a function</h2>
<p>In Haskell a function takes one or more things (referred to as arguments), and will give you back something else (referred to as the output or return value).</p>
<p>So to recap, a Haskell function takes something and gives something else back. This is all a &lsquo;normal&rsquo; function can do in Haskell, I will discuss the &lsquo;non-normal&rsquo; functions, ones that can effect the program state later, they are more advanced.</p>
<h2 id="kinds-of-data">Kinds of Data</h2>
<p>So we know what a function is, so what can I give it. In other words what types can the function accept.</p>
<p>Some commonly used data types defined in <code>prelude</code> (the standard Haskell library that is always available) are:</p>
<ul>
<li><code>Int</code> / <code>Integer</code></li>
<li><code>Float</code></li>
<li><code>Char</code></li>
<li><code>String</code></li>
<li><code>Bool</code></li>
</ul>
<p>Just to be sure lets recap those data types, in Haskell it is very important to have a good understanding of types.</p>
<p><code>Int</code> / <code>Integer</code> refer to whole numbers the only difference is the bounds of the number, the maximum and minimum it can be, this is due to memory allocation. The <code>Int</code> supports integers in the range [-2^29 &hellip; 2^29-1], where as <code>Integer</code> is an arbitrary precision type, it can hold any number subject to the machines memory limitations.</p>
<p>A <code>Float</code> holds a decimal value.</p>
<p>A <code>Char</code> hold a single character.</p>
<p>A <code>String</code> holds multiple characters, in actual fact the <code>String</code> data type is actually a <span class="underline">Type Alias</span> for <code>[Char]</code>, a list of character, we will be using this fact later in this series.</p>
<p>Finally <code>Bool</code> which is a Boolean value which is a logical result either <code>True</code> or <code>False</code>.</p>
<p>As you discover <span class="underline">Algebraic Data Types</span> you will find that the above list is in fact essentially infinite, I will cover this topic in detail in a later post.</p>
<h2 id="applying-a-function">Applying a Function</h2>
<p>Haskell gives us two ways of applying <strong>Arguments</strong> to a <strong>Function</strong>.</p>
<h3 id="prefix-application">Prefix Application</h3>
<p><strong>Prefix</strong> application is where the function name comes before the arguments. In Haskell to apply a function we don&rsquo;t bother with round brackets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">sum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1">-- sum ::  Num a =&gt; [a] -&gt; a</span>
<span class="c1">-- Returns the sum of the list</span>

<span class="nf">max</span> <span class="mi">4</span> <span class="mi">19</span>
<span class="c1">-- max :: Ord a =&gt; a -&gt; a -&gt; a</span>
<span class="c1">-- Returns the largest of its two arguments</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see the function name is given before the arguments to this is a <span class="underline">Prefix</span> application. Note the <code>--</code> above are used to give comments in a Haskell source code file.</p>
<h3 id="infix-application">Infix Application</h3>
<p>However, some functions would look strange if they was written in a <span class="underline">Prefix</span> style. We have another option <strong>Infix</strong> application.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="c1">-- (+) :: Num a =&gt; a -&gt; a -&gt; a</span>
<span class="c1">-- Returns the sum of its arguments</span>

<span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="c1">-- (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span>
<span class="c1">-- Returns the result of the application of a logical &#39;and&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>As you can see the function name is in between the arguments of the function.</p>
<p>However, sometimes we may want to write a infix function in a prefix style this can be done very easily, by enclosing it in round brackets.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="c1">-- (+) :: Num a =&gt; a -&gt; a -&gt; a</span>
<span class="c1">-- Returns the sum of its arguments</span>

<span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="kt">True</span> <span class="kt">False</span>
<span class="c1">-- (&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool</span>
<span class="c1">-- Returns the result of the application of a logical &#39;and&#39;</span>
</code></pre></td></tr></table>
</div>
</div><p>We may also want to write a prefix function in a infix function in a prefix style, this can be done by enclosing the function name in <span class="underline">back ticks</span> <code>`</code>.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="mi">4</span> <span class="p">`</span><span class="n">max</span><span class="p">`</span> <span class="mi">19</span>
<span class="c1">-- max :: Ord a =&gt; a -&gt; a -&gt; a</span>
<span class="c1">-- Returns the largest of its two arguments</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="composing-a-function">Composing a Function</h2>
<p>Know we know how to apply a function, we want to know how we can string functions together to achieve our goal.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">square</span>  <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="c1">-- Returns the square of a number</span>

<span class="nf">cube</span>    <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="c1">-- Returns the cube of a number</span>

<span class="nf">largest</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="c1">-- Returns the largest of two numbers</span>

<span class="p">(</span><span class="n">cube</span> <span class="mi">2</span><span class="p">)</span> <span class="p">`</span><span class="n">largest</span><span class="p">`</span> <span class="p">(</span><span class="n">square</span> <span class="mi">3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>In the example above we have used <code>largest</code> in an infix style, because to me that makes the code easier to understand, both <code>cube</code> and <code>square</code> have both been used prefix because again that style makes the code easier to read in this situation.</p>
<p>The <code>largest</code> function has been composed with both <code>cube</code> and <code>square</code> the result of those calculations are given to the <code>largest</code> function (and evaluated when required, Haskell is <a href="https://en.wikipedia.org/wiki/Lazy%5Fevaluation" target="_blank" rel="noopener noreffer">lazy</a>.</p>
<h2 id="defining-a-new-function">Defining a new Function</h2>
<p>Right enough reading, I think its about time we wrote some Haskell for ourselves.</p>
<ol>
<li>Open your favourite text editor, I like to use <strong>Emacs</strong> I will be making a series about Emacs soon.</li>
<li>Create a file called <code>basic_functions.hs</code> all Haskell source code files will have the <code>.hs</code> file extension.</li>
<li>Lets now define the <code>square</code>, <code>cube</code> and <code>largest</code> functions.</li>
<li>We are using Haskell so <strong>Types Matter</strong>, although the <strong>Haskell Type System can infer types</strong> I always give a <strong>Type Signature</strong> for every function I define.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>Now its time for the actual function, what we need the function to do is get a value and return its square. Lets use the power operator <code>(^)</code>.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">square</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">square</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>That&rsquo;s it, our first Haskell function, write the cube function then check your answer.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">cube</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">cube</span> <span class="ow">=</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>Have you got the same? This is a new concept I have not introduced yet. This feature of Haskell is called <strong>Partial Function Application</strong>, its allows us to simplify the definition of functions, to essentially their logical/base components. Don&rsquo;t you :heart: Haskell.</li>
<li>The <code>largest</code> function behaves identically to the <code>max</code> function, so why not use that.</li>
</ol>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">largest</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">largest</span> <span class="ow">=</span> <span class="n">max</span>
</code></pre></td></tr></table>
</div>
</div><ol>
<li>The above is just example, in any other situation you might as well us the <code>prelude</code> function <code>max</code> and avoid  unnecessary definitions</li>
<li>Its time to test our new functions, open your favourite terminal emulator, move to the directory where the Haskell source code file is stored and enter <code>ghci basic_functions.hs</code>, this will load the file in to the <span class="underline">Glasgow Haskell Compiler Interactive</span>.</li>
<li>Now from the GHCI prompt, enter <code>cube 4</code> you should see the result <code>64</code> displayed directly in the terminal windows</li>
<li>Enter <code>square 9</code> you should see the result <code>81</code>.</li>
<li>Congratulations, you&rsquo;ve just written your first Haskell code.</li>
</ol>
<p>I hope you&rsquo;ve picked up some ideas about functions now, we will be building on these on later posts. The next post will be about a very cool Haskell feature <span class="underline">Lists and Comprehensions</span>, see you there.</p>
]]></description>
</item><item>
    <title>Lists and Comprehensions</title>
    <link>https://kylecotton.github.io/lists-and-comprehensions/</link>
    <pubDate>Tue, 28 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/lists-and-comprehensions/</guid>
    <description><![CDATA[<p>Welcome back to the next post now we will be learning about <span class="underline">List and comprehensions</span>, they form a large part of a typical Haskell program, so lets find out more about them now.</p>
<h2 id="the-list">The List</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">nums</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">nums</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>

<span class="nf">chars</span>  <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">chars</span>  <span class="ow">=</span>  <span class="p">[</span><span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;s&#39;</span><span class="p">,</span> <span class="sc">&#39;k&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">]</span>

<span class="nf">str</span>  <span class="ow">::</span> <span class="kt">String</span>
<span class="nf">str</span>  <span class="ow">=</span>  <span class="s">&#34;haskell&#34;</span>

<span class="nf">funcs</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">]</span>
<span class="nf">funcs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">product</span><span class="p">,</span> <span class="n">sum</span><span class="p">]</span>

<span class="nf">evenList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">evenList</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="mi">100</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>Haskell loves lists! Due to the <span class="underline">Type System</span>, all list can only contain elements of the same type.</p>
<p>Haskell also allows for infinite lists. An example of this can be seen below, I have extended the definition above to include all the even numbers - cool right! However, when we use infinite lists we have to ensure that we write robust code, so that we know our programs will eventually terminate. This will become even more important when we talk about recursion.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">evenList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">evenList</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>## Basic List Operations
Now we know about the list, lets look into some basic functions that can be applied to a list.
This list shows us some of the most common functions, that are typically used with a <span class="underline">List Comprehension</span></p>
<ul>
<li><code>product</code> - returns the product of all the numbers in a list</li>
<li><code>sum</code> - returns the sum of all the numbers in a list</li>
<li><code>and</code> - applied a logic &lsquo;and&rsquo; to the values in a list and returns the result</li>
<li><code>or</code> - applied a logic &lsquo;or&rsquo; to the values in a list and returns the result</li>
<li><code>!!</code> - the infix direct access operator, returns the element at the nth position of the list</li>
<li>Plus a lot more. Check out <a href="https://hoogle.haskell.org/" target="_blank" rel="noopener noreffer">Hoogle</a>, for a list of functions.</li>
</ul>
<p>Now lets see some examples of how these functions are used.</p>
<p><code>product [1,2,3,4,5]</code> will return the value of <code>1*2*3*4*5</code> which is <code>120</code>.</p>
<p><code>sum [1,2,3,4,5]</code> will return the value of <code>1+2+3+4+5</code> which is <code>15</code>.</p>
<p><code>and [True,True,False,False,True]</code> will return the value of <code>True &amp;&amp; True &amp;&amp; False &amp;&amp; False &amp;&amp; True</code> which is <code>False</code>. Since there exists a <code>False</code> within the list.</p>
<p><code>or [True,True,False,False,True]</code> will return the value of <code>True || True || False || False || True</code> which is <code>True</code>. Since there exist a <code>True</code> within the list.</p>
<p><code>[0,2..100] !! 10</code> will return the element of the list <code>[0,2..10]</code> that is in the 10th position. <strong><strong>Warning</strong></strong> , remember that list in Haskell and  most programming languages are <strong><strong>Zero Indexed</strong></strong>, we start counting from zero not one.</p>
<h2 id="list-comprehensions">List Comprehensions</h2>
<p>Now we have the background knowledge its time we learn some <strong>List Comprehensions</strong></p>
<p>I like to think of a list comprehension in exactly the same way I think about <span class="underline">Set Notation</span> from mathematics.
I&rsquo;m going to show the various part that make up a list comprehension.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>

<span class="c1">-- [x | This part of the list comprehension shows us what</span>
<span class="c1">--      is added to the resulting list for each element</span>
<span class="c1">--      of the generating list.</span>

<span class="c1">--      x &lt;- [1..10] This part of the list comprehension</span>
<span class="c1">--                   is called the generator. It gets</span>
<span class="c1">--                   the elements from the generating</span>
<span class="c1">--                   list.</span>

<span class="c1">--        &lt;- This is the &#39;drawn from&#39; operator.</span>

<span class="c1">--               , odd x] This final part of is known</span>
<span class="c1">--                            as the guard, it almost like</span>
<span class="c1">--                            an if statement. The element</span>
<span class="c1">--                            is added only if this is true.</span>
</code></pre></td></tr></table>
</div>
</div><p>The above may look complicated but that is more of the formal introduction to <strong>List Comprehensions</strong>.</p>
<h2 id="examples">Examples</h2>
<p>Now lets run through some examples. I may introduce some more exciting functions as we go along.
I will also take you through my thought process as I come up with a solution.</p>
<ul>
<li>Create a list comprehension that gives us all of the positive even numbers.
<ul>
<li>So the answer needs to choose only the even numbers, so we will be needing a guard for even numbers. We will have to use the <code>even</code> function.
<ul>
<li>Lets find out more <strong>info</strong> about the even function.</li>
<li>Open <code>ghci</code> as you have done previously</li>
<li>Enter <code>:info even</code> this can also be shortened to <code>:i even</code>.</li>
<li>Take note of the type, we give it an <code>Integral</code> which is either a <code>Int</code> or <code>Integer</code> and it returns a <code>Bool</code></li>
<li>This is exactly what we want, so lets use this handy function.</li>
</ul>
</li>
<li>We want <strong><strong>all</strong></strong> of the positive even numbers so we are going to have to use an infinite list. This is the generator.</li>
<li>We don&rsquo;t need to apply any function to the number that is added from the generator.</li>
<li>So the final List Comprehension becomes the one below.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="p">],</span> <span class="n">even</span> <span class="n">x</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Create a list of the first 100 perfect squares.
<ul>
<li>When creating this list we can either, check if a number is a perfect square using a guard then add it, or create the perfect squares ourselves. I personally think the latter is easier.</li>
<li>So we won&rsquo;t be needing any guards for this solution.</li>
<li>The generator should give us all of the first 100 integers so that we can make them into the perfect squares.</li>
<li>We will need to apply a functions to each of the values, we need to square them.</li>
<li>So the final List Comprehension becomes the one below.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span><span class="ow">&lt;-</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Find the product of the first 100 perfect squares
<ul>
<li>This problem would be very complicated to solve without the aid of a computer.</li>
<li>We will be composing a previous solution with one of the list functions we introduced earlier in this post.</li>
<li>We already have list of the first 100 perfect squares, now we need to get the product of all of them.</li>
<li>Lets get more <strong>info</strong> about the <code>product</code> function
<ul>
<li>Lets open <code>ghci</code></li>
<li>Enter <code>:i product</code></li>
<li>Note the function takes a list of numbers and returns a single number</li>
<li>This is exactly what we want, lets use the product function</li>
</ul>
</li>
<li>So the final List Comprehension becomes the one below.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">product</span> <span class="p">[</span><span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span><span class="ow">&lt;-</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]]</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Define a function that takes a <code>String</code> argument and returns a <code>String</code> containing only the letters of the input but now all lowercase.
<ul>
<li>From one of my previous post I said a <code>String</code> is a <strong>Type Alias</strong> for <code>[Char]</code>. We are going to have to use this fact to answer this question.</li>
<li>We have to only add characters that  are letters so we are going to have to use a guard. Lets find out more <strong>info</strong> about the <code>isLetter</code> function.
<ul>
<li>As previously use <code>ghci</code> to get more information about the function</li>
<li>We can see that the function takes a <code>Char</code> and returns a <code>Bool</code> this is perfect for what we want</li>
<li>We are given a string so that must form part of the generator</li>
<li>Finally we must make all of the characters lowercase, so we must apply a function to each of them. Lets look at the <code>toLower</code> function
<ul>
<li>Again use <code>ghci</code> to get more <strong>info</strong></li>
<li>We see that the function takes a <code>Char</code> and returns a <code>Char</code> this is what we want</li>
<li>So the final list comprehension becomes</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">f</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">toLower</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span><span class="ow">&lt;-</span><span class="n">xs</span><span class="p">,</span> <span class="n">isLetter</span> <span class="n">x</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>The above is a more complex example, lets go through the main parts of it again for clarity.</p>
<p>For this problem we have defined a function <code>f</code> that takes a <code>String</code> as input and returns a <code>String</code>.
The input string is the <code>xs</code> on the left hand side of the <span class="underline">assignment operator <code>=</code></span>.
We go through each element of <code>xs</code> which has type <code>[Char]</code>, we call this element <code>x</code>.
First we check if it is a letter, if <code>False</code> it is discarded, if <code>True</code> we apply the <code>toLower</code> function, making it lowercase then add it to the list to  be returned.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope this post has been beneficial. There are many situations in which list comprehension can massively simplify problems that you will face so always keep them in mind. In the next post I will be covering Lists and Recursion. Kyle out!</p>
]]></description>
</item><item>
    <title>Recursion</title>
    <link>https://kylecotton.github.io/recursion/</link>
    <pubDate>Wed, 29 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/recursion/</guid>
    <description><![CDATA[<p>Our research into <span class="underline">Haskell  Lists</span> continues.
Before we can look into using recursive functions with lists, I think first we need to cover what recursion is.
In my opinion recursion is one of the most important concepts for any <span class="underline">Functional Programmer</span>.</p>
<blockquote>
<p>Recursion: Where a function calls its self from within its definition.</p>
</blockquote>
<!--quoteend-->
<blockquote>
<p>Case: A condition that could happen, eg the number could be zero or it may not be.</p>
</blockquote>
<p>Lets kick off with an example of a recursive example then I&rsquo;ll work through it with you. Keep in mind the definitions of <strong>recursion</strong> and a <strong>case</strong> from above.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">factoralRec</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">factoralRec</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">factoralRec</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factoralRec</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="cm">{------------------------------------------
</span><span class="cm">How the lazy evaluation occurs:
</span><span class="cm">factoralRec 4
</span><span class="cm">4 * factoralRec (4-1)
</span><span class="cm">4 * factoralRec 3
</span><span class="cm">4 * 3 * factoralRec (3-1)
</span><span class="cm">4 * 3 * factoralRec 2
</span><span class="cm">4 * 3 * 2 * factoralRec (2-1)
</span><span class="cm">4 * 3 * 2 * factoralRec 1
</span><span class="cm">4 * 3 * 2 * 1 * factoralRec (1-1)
</span><span class="cm">4 * 3 * 2 * 1 * factoralRec 0
</span><span class="cm">4 * 3 * 2 * 1 * 1
</span><span class="cm">24
</span><span class="cm">------------------------------------------}</span>
</code></pre></td></tr></table>
</div>
</div><p>Above we have an example of using recursion to find the factorial of a number. I have also added a <strong>multi-line comment</strong> (using the <code>{-COMMENT-}</code> syntax) to show how the <strong>lazy evaluation</strong> of an expression occurs in Haskell.</p>
<h2 id="base-case">Base Case</h2>
<p>The base case is the most important aspect of any recursive function, this is where the recursion ends (the program doesn&rsquo;t call its self in this case).
We are always computing to get to the base case, in the above example, we are decreasing the number that is passed in the the <code>factoralRec</code> function by one each time.
We then reach the <strong>Base Case</strong> <code>factoralRec 0 = 1</code> - this is where the recursive calls stop and the program can begin to <strong>unwind</strong>, the theory behind recursion can be quite complex for a beginner but read <a href="https://en.wikipedia.org/wiki/Recursion%5F%28computer%5Fscience%29" target="_blank" rel="noopener noreffer">here</a> for more information.</p>
<h2 id="recursive-call">Recursive Call</h2>
<p>Alas,  we may have the best base case but any <span class="underline">recursive</span> function still needs a <strong>recursive call</strong>, the is where the function calls it self.
You can see this in the line <code>factoralRec x = x * factoralRec (x-1)</code>, this may seem complicated at first.
I was also initially confused, I used to ask myself, &lsquo;<em>how does the compiler know what the function is if its used in its own the definition?</em>'.</p>
<p>After the code I have shown how the evaluation would occur, I have omitted some brackets to make it easier to understand, as the bracketing doesn&rsquo;t matter with this function.
I hope this makes the recursive step easier to understand.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This has been a <span class="underline">quick and dirty</span> introduction to <span class="underline">Recursion</span>, in the next post I will be covering how we can use this new knowledge with particular applications to list.</p>
]]></description>
</item><item>
    <title>Lists and Recursion</title>
    <link>https://kylecotton.github.io/lists-and-recursion/</link>
    <pubDate>Thu, 30 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/lists-and-recursion/</guid>
    <description><![CDATA[<p>Now you know a little about <span class="underline">Recursion</span> its time we use this knowledge for good - lets use it with a <span class="underline">Haskell Favorite, Lists!</span></p>
<h2 id="how-the-list-is-built">How the list is built</h2>
<p>I&rsquo;ve spoken about the <strong>List Data Type</strong> previously in the <strong><strong>Haskell for Beginners: Lists and Comprehensions</strong></strong> post, but we need to know a little more about them before we can apply our newly found recursive knowledge to them.</p>
<p><strong><strong>A list is build not made</strong></strong>, let me explain. Every list is build using only <code>:</code>, &lsquo;cons&rsquo; and <code>[]</code> the empty list.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- Note: This is not valid Haskell code</span>
<span class="c1">--         only the representations as</span>
<span class="c1">--         lists are accurate.</span>

<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="p">(</span><span class="mi">2</span><span class="kt">:</span><span class="p">(</span><span class="mi">3</span><span class="kt">:[]</span><span class="p">))</span>

<span class="s">&#34;list&#34;</span>  <span class="ow">=</span> <span class="p">[</span><span class="err">’</span><span class="n">l</span><span class="err">’</span><span class="p">,</span><span class="err">’</span><span class="n">i</span><span class="err">’</span><span class="p">,</span><span class="err">’</span><span class="n">s</span><span class="err">’</span><span class="p">,</span><span class="err">’</span><span class="n">t</span><span class="err">’</span><span class="p">]</span> <span class="ow">=</span> <span class="err">’</span><span class="n">l</span><span class="err">’</span><span class="kt">:</span><span class="p">(</span><span class="err">’</span><span class="n">i</span><span class="err">’</span><span class="kt">:</span><span class="p">(</span><span class="err">’</span><span class="n">s</span><span class="err">’</span><span class="kt">:</span><span class="p">(</span><span class="err">’</span><span class="n">t</span><span class="err">’</span><span class="kt">:[]</span><span class="p">)))</span>
</code></pre></td></tr></table>
</div>
</div><p>The above may look complicated, but lets go through it. A very important thing to remember for later is that the <span class="underline">Base</span> of any list is the <strong><strong>Empty List</strong></strong> <code>[]</code>.
From here we append elements onto the list using the &lsquo;cons&rsquo; (short for construct) <code>:</code> operator.</p>
<p>The <span class="underline">Type Signature</span> of gives a clear picture of what the operator does <code>(:) :: a -&gt; [a] -&gt; [a]</code>, if your unsure how to interpret this signature check out the <strong><strong>Haskell for Beginners: Understanding Haskell Documentation</strong></strong> post, which covers this in detail.</p>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>The last thing we need to know is pattern matching, this allows us to split a list if it <strong>matches a pattern</strong>, lets look at an example to make things easier to understand.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">patternMatch</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">patternMatch</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;List with at least 2 elements&#34;</span>
<span class="nf">patternMatch</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span>   <span class="ow">=</span> <span class="s">&#34;Non-Empty List&#34;</span>
<span class="nf">patternMatch</span> <span class="kt">[]</span>      <span class="ow">=</span> <span class="s">&#34;Empty List&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>Above we have a nice example of pattern matching in action.</p>
<p>Note, the <code>_</code> character matches with anything, we use this if we don&rsquo;t care what the actual value is, it allows for compiler optimization. I&rsquo;ll give an example using the values from a pattern match a little later.</p>
<p>Let me now go through each pattern and describe what it means.</p>
<ul>
<li><code>[]</code> - Use this statement if the input is the empty list.</li>
<li><code>(_:_)</code> - Use this statement if there is at least one element in the list. This is because the final <code>_</code> may be the empty list, but it may contain any number of elements or it could even be infinite.</li>
<li><code>(_:_:_)</code> - This pattern is very similar to the one above, but it allows us to say this list contains at least two elements.</li>
<li>We can pattern match any finite number of elements from a list (if you want to type out the pattern :-) ).</li>
</ul>
<p>I advise you copy and play about with this example, you will notice that the order of the expressions does indeed matter. Haskell will use the first available pattern that matches so if we swapped lines two and three, then this statement <code>patternMatch (_:_:_) = &quot;List with Two+ Elements&quot;</code> would be redundant.</p>
<p>Note, we are using a <span class="underline">Polymorphic Type, &lsquo;a'</span>, we will be covering this when we go through <strong>Type Classes</strong>.</p>
<p>Note, the last line <code>patternMatch [] = &quot;Empty List&quot;</code>, is not strictly a pattern match, but it is required.</p>
<p>If you omit that line and then try to evaluate, <code>patternMatch []</code> you will get an error, <code>Exception: Non-exhaustive patterns in function patternMatch</code>.
This means there is a <strong><strong>case</strong></strong> that we have not considered, so when Haskell trys to replace it, it doesn&rsquo;t know what to replace it with and has no choice but to raise an exception.</p>
<p>As you will find out, if you program in a correct <span class="underline">functional</span> way <span class="underline">run time errors</span> will be extremely rare.</p>
<p>Pattern matching can also be used to extract elements from a list, lets run through a quick example of how this would work.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">patternMatch</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">patternMatch</span> <span class="p">(</span><span class="n">x1</span><span class="kt">:</span><span class="n">x2</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&#34;First Element: &#34;</span>     <span class="o">++</span> <span class="n">show</span> <span class="n">x1</span> <span class="o">++</span>
                          <span class="s">&#34; Second Element: &#34;</span>   <span class="o">++</span> <span class="n">show</span> <span class="n">x2</span> <span class="o">++</span>
                          <span class="s">&#34; Rest of the List: &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">xs</span>
<span class="nf">patternMatch</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>     <span class="ow">=</span> <span class="s">&#34;First Element: &#34;</span>     <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span>
                          <span class="s">&#34; Rest of the List: &#34;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">xs</span>
<span class="nf">patternMatch</span> <span class="kt">[]</span>         <span class="ow">=</span> <span class="s">&#34;Empty List&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>The biggest change in this version of the code in terms of the <span class="underline">pattern matching</span> is that we have now name the elements of the pattern, where before we used <code>_</code> now we have used variables, <code>x1</code>,~x2~,~x~,~xs~ in this particular example. This allows us to extract elements from the list.</p>
<p>In the above example I have used a new function <code>show</code>, so lets go through it.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Show</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="o">...</span>
  <span class="n">show</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
  <span class="o">...</span>
    <span class="c1">-- Defined in ‘GHC.Show’</span>
</code></pre></td></tr></table>
</div>
</div><p>Using <span class="underline">ghci</span> we get the following <span class="underline">info</span>, you know how to read this from the  <strong><strong>Haskell for Beginners: Understanding Haskell Documentation</strong></strong> post. The function takes an input of any type (that can be showed, this related to <span class="underline">Type Classes</span> which we are discussing later), and returns a <code>String</code> version of it.</p>
<p>Here are some example of show:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">4</span>
<span class="s">&#34;4&#34;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">True</span>
<span class="s">&#34;True&#34;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="s">&#34;[1,2,3]&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>The <code>++</code> operator just combines two lists returning a new list.</p>
<h2 id="examples">Examples</h2>
<p>Now we&rsquo;ve got the background knowledge, lets run through some examples.
I may introduce some more exciting functions as we go along.
I will also take you through my thought process as I come up with a solution.</p>
<ul>
<li>Create a recursive function list that gives us all of the positive even numbers from a list.
<ul>
<li>When creating a recursive function, we first need to think about the base case. In this example that is the empty list, when the empty list is input the empty list should be returned.</li>
<li>Now we need to think about the recursive step, we have to select only the even numbers so we will have to use a guard, this will be done in conjunction with a <strong>pattern match</strong>
<ul>
<li>If the number is a even number it must be added to the list. We must continue checking the rest of the list till we reach the empty list the base case.</li>
<li>If the number is odd we ignore it and continue with the rest of the list.</li>
</ul>
</li>
<li>So the final function could be something like below. When we use guards in functions they are represented with a pipe <code>|</code>, the otherwise statement will always be used if none of the above cases are met. You don&rsquo;t have to use the <code>otherwise</code> however, I <strong><strong>heavily recommend</strong></strong> it since it will avoid the dreaded <code>Exception: Non-exhaustive patterns in function evenList</code> error.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">evenList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">evenList</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">evenList</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">even</span> <span class="n">x</span>    <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">evenList</span> <span class="n">xs</span>
                <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span>     <span class="n">evenList</span> <span class="n">xs</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Create a function that returns the square of all of the elements in a list.
<ul>
<li>First we always consider the base case. Again this will be the empty list, which will just return the empty list.</li>
<li>Now we think about the recursive step
<ul>
<li>All we need to do for the recursive step is go through and square all of the elements until we reach the base case (the empty list).</li>
</ul>
</li>
<li>So the final function could look something like this.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">squareRec</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">squareRec</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">squareRec</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="kt">:</span> <span class="n">squareRec</span> <span class="n">xs</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Find the product of the square of all the numbers in a list.
<ul>
<li>This problem is slightly different, unlike the <span class="underline">List Comprehension</span> method where we get the list then find the product in this example it will be easier to do it all in one function.</li>
<li>As always lets consider the base case, here when we get the empty list we must return an integer. When we get the empty list we must return <code>1</code> as this is the identity for multiplication. Just like <code>0</code> is the identity for addition.</li>
<li>Now lets consider the recursive step.
<ul>
<li>We need to get the element out of the list, we can use pattern matching to do this.</li>
<li>We then need to square this element</li>
<li>Then we need to multiply it my the result of the rest of the list going through the same process, this is the recursive part.</li>
</ul>
</li>
<li>So the final function could look something like this.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">squareProdRec</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">squareProdRec</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">squareProdRec</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="n">squareProdRec</span> <span class="n">xs</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Define a function that takes a <code>String</code> argument and returns a <code>String</code> containing only the letters of the input but now all lowercase.
<ul>
<li>From one of my previous post I said a <code>String</code> is a <strong>Type Alias</strong> for <code>[Char]</code>. We are going to have to use this fact to answer this question.
<ul>
<li>We will treat the <code>String</code> as a list of <code>Char</code>, so that we can recurse over it.</li>
</ul>
</li>
<li>The first thing we need to consider is the base case this will be the empty list, inputting the empty list should return the empty list.</li>
<li>Now the recursive step, we have two cases, the <code>Char</code> is a letter and it is not a letter. We will have to use guards.
<ul>
<li>If the <code>Char</code> is a letter (<code>isLetter</code> returns <code>True</code>), then we apply the <code>toLower</code> function, add it to the resulting list and continue with the rest of the list until we reach the empty list, out base case.</li>
<li>If the <code>isLetter</code> returns <code>False</code> we ignore it and continue with the rest of the list.</li>
</ul>
</li>
<li>So the final function becomes</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">lowerLetterRec</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span>  <span class="kt">String</span>
<span class="nf">lowerLetterRec</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">lowerLetterRec</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">|</span> <span class="n">isLetter</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">toLower</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">lowerLetterRec</span> <span class="n">xs</span>
                      <span class="o">|</span> <span class="n">otherwise</span>  <span class="ow">=</span>             <span class="n">lowerLetterRec</span> <span class="n">xs</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="conclusion">Conclusion</h2>
<p>Well there you have it another way of messing with lists.
Isn&rsquo;t recursion in Haskell great!
In the next post we will be covering one of my favorite topics, <strong><strong>Haskell for Beginners: High Order Functions</strong></strong>.
See you in the next post, Kyle out!</p>
]]></description>
</item><item>
    <title>High Order Functions</title>
    <link>https://kylecotton.github.io/high-order-functions/</link>
    <pubDate>Fri, 31 May 2019 00:00:00 &#43;0000</pubDate>
    <author>Author</author>
    <guid>https://kylecotton.github.io/high-order-functions/</guid>
    <description><![CDATA[<p>I&rsquo;ve got a good post in store today, <strong><strong>High Order Functions</strong></strong>, one of my Haskell favourites.
We&rsquo;ve previously covered, <strong>List Comprehensions</strong> and <strong>Recursion</strong> for getting stuff done in Haskell,
now we will be covering a slightly more advanced topic, but one I find very cool.</p>
<h2 id="why-so-high">Why so high?</h2>
<p>You might be asking yourself, why these functions are so high?
I&rsquo;ll first explain what exactly is a high order function as you may have not encountered them before.
A high order function is a function that has an argument that is its self a function and or returns a function.
That&rsquo;s it, simple isn&rsquo;t it. Keep reading to see a little of what we can do with them.</p>
<h2 id="partial-function-application">Partial Function Application</h2>
<p>Before we can get stuck into the <strong>High Order Function</strong> I&rsquo;m going to explain another Haskell favourite - <strong>Partial Function Application</strong>.
This is where one or more of the function arguments are omitted when the function is used or applied.
An easy way of thinking of this is that that any arguments that are passed are then embedded in the result, we the function result only requires the remaining arguments.
As always lets have a look at I&rsquo;ll give an example of this below, this is one of the more complex examples we have looked at so far.</p>
<p>Below you can see the function I have defined, lets look into how <strong>Partial Function Application</strong> works using this as an example.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">addSome</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addSome</span> <span class="n">x1</span> <span class="n">x2</span> <span class="n">x3</span> <span class="ow">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span>
</code></pre></td></tr></table>
</div>
</div><p>Using <code>GHCI</code> in a terminal, we can investigate this a little more.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">addSome</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">6</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">addSome</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">x</span> <span class="mi">3</span>
<span class="mi">6</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">x</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">18</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span> <span class="ne">error</span><span class="kt">:</span>
    <span class="err">•</span> <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span><span class="p">))</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="err">‘</span><span class="n">print</span><span class="err">’</span>
        <span class="p">(</span><span class="n">maybe</span> <span class="n">you</span> <span class="n">haven&#39;t</span> <span class="n">applied</span> <span class="n">a</span> <span class="n">function</span> <span class="n">to</span> <span class="n">enough</span> <span class="n">arguments</span><span class="o">?</span><span class="p">)</span>
    <span class="err">•</span> <span class="kt">In</span> <span class="n">a</span> <span class="n">stmt</span> <span class="kr">of</span> <span class="n">an</span> <span class="n">interactive</span> <span class="kt">GHCi</span> <span class="n">command</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">addSome</span> <span class="mi">10</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">y</span> <span class="mi">90</span> <span class="mi">100</span>
<span class="mi">200</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">x</span>
<span class="nf">x</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">y</span>
<span class="nf">y</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">i</span> <span class="n">x</span>
</code></pre></td></tr></table>
</div>
</div><p>The first example is just standard way function is used; just summing the three <code>Int</code> arguments that have been passed to it.
The second example is the first time we use <strong>Partial Function Application</strong>, here we have partially applied the first two arguments to the function.
Notice, when we try to evaluate <code>x</code> Haskell doesn&rsquo;t know how to show it us, because it is a function, you can see this from the <strong>Type Signature</strong> <code>x :: Int -&gt; Int</code> so an error is raised, as seen above.</p>
<h2 id="function-composition">Function Composition</h2>
<p>Haskell has functions, it also has functions of functions and functions of functions of functions of &hellip;
So lets look a little it how we can <span class="underline">Compose</span> functions in Haskell.</p>
<p>To compose functions in Haskell we use the <span class="underline">Function Composition Operator</span> <code>.</code>. This may seem strange syntax at first.
Lets look at some examples and see how we can use this to our advantage.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">powerTwo</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">powerTwo</span>   <span class="ow">=</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>

<span class="nf">powerThree</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">powerThree</span> <span class="ow">=</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span>

<span class="nf">somePower</span> <span class="ow">=</span> <span class="n">powerTwo</span> <span class="o">.</span> <span class="n">powerThree</span>
</code></pre></td></tr></table>
</div>
</div><p>Above I have added some code, this is what we will be using to explore this a little further.</p>
<p>First notice, I have not included a <strong>Type Signature</strong> for the <code>powerSix</code> function;
the type signatures are not required however, I <strong><strong>Strongly Recommend</strong></strong> you always add one in,
they can frequently ping up errors in the code that are due to an error in the programs logic,
(something the computer cannot do for us).</p>
<p>Now you can see that we have composed the functions: <code>powerTwo</code> and <code>powerThree</code>.
Take a minute to think of what the result of this operation will be.
Remember back to Mathematics, we apply the right most function first then move to the left,
so in effect we have the function <code>(x^3)^2</code>.</p>
<p>Lets try evaluating some values and see if they are what we expect.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="mi">1</span>
<span class="mi">1</span>
<span class="c1">-- (1^3)^2 = 1</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="mi">2</span>
<span class="mi">64</span>
<span class="c1">-- (2^3)^2 = 64</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="mi">3</span>
<span class="mi">729</span>
<span class="c1">-- (3^3)^2 = 729</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="mi">4</span>
<span class="mi">4096</span>
<span class="c1">-- (4^3)^2 = 4096</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="c1">-- ((-1)^3)^2 = 1</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="mi">1000000</span>
<span class="c1">-- ((-10)^3)^2 = 1000000</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">somePower</span>  <span class="s">&#34;Hello, World!&#34;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">99</span><span class="kt">:</span><span class="mi">11</span><span class="kt">:</span> <span class="ne">error</span><span class="kt">:</span>
    <span class="err">•</span> <span class="kt">Couldn&#39;t</span> <span class="n">match</span> <span class="n">expected</span> <span class="kr">type</span> <span class="err">‘</span><span class="kt">Integer</span><span class="err">’</span> <span class="n">with</span> <span class="n">actual</span> <span class="kr">type</span> <span class="err">‘</span><span class="p">[</span><span class="kt">Char</span><span class="p">]</span><span class="err">’</span>
    <span class="err">•</span> <span class="kt">In</span> <span class="n">the</span> <span class="n">first</span> <span class="n">argument</span> <span class="kr">of</span> <span class="err">‘</span><span class="n">somePower</span><span class="err">’</span><span class="p">,</span> <span class="n">namely</span> <span class="err">‘</span><span class="s">&#34;Hello, World!&#34;</span><span class="err">’</span>
      <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">somePower</span> <span class="s">&#34;Hello, World!&#34;</span>
      <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="err">‘</span><span class="n">it</span><span class="err">’</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">somePower</span> <span class="s">&#34;Hello, World!&#34;</span>

<span class="c1">-- The inferred *Type Signature* for the ~somePower~ function does not allow</span>
<span class="c1">--  for ~String~ types so an error is raised, as Haskell cannot handle it.</span>
</code></pre></td></tr></table>
</div>
</div><p>Above I have evaluated the <code>somePower</code> function with a range of value to see the result.
Hopefully I you know have a better understanding of how <strong>Function Composition</strong> work in Haskell
and how we can use it.</p>
<h2 id="filter">Filter</h2>
<p>Now its time to get stuck into a few high order functions available in Haskell <code>Prelude</code>.
<code>Filter</code> is the first of these functions; <code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>,
the filter takes a <strong>Predicate Function</strong> and a <strong>List</strong> which returns a <strong>List</strong>.
Every item is passed to the predicate function those that evaluate to <code>True~are added, the ones that evaluate to ~False</code> are omitted.</p>
<p>This allows us to easily <strong>filter</strong> elements from any given list.
Lets look at an example of how we can use the filter function.</p>
<ul>
<li>Create a high order function that gives us all of the positive even numbers from a list.
<ul>
<li>Thinking about this at a <span class="underline">higher</span> level, we know we need only the positive even numbers</li>
<li>So lets <code>filter</code> these out into our result</li>
<li>we need a function that will return <code>True</code> when a positive even number is passed and <code>False</code> otherwise.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">predicate</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">predicate</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">even</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span>

<span class="nf">posEven</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">posEven</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">predicate</span>

<span class="c1">---------------------------------------------</span>

<span class="nf">posEvenNew</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">posEvenNew</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">even</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Above you can see my solution to the problem; I have included two example solutions.
The first is more verbose, it has a separate predicate function that is then used in the final function.
The second example is much prettier, it uses <strong>Lambda</strong> functions, this is something we will be covering in the next post.</p>
<p>Both functions work in a similar manner, each of the value of the lists are passed to the predicate function; whether that be the separate <code>predicate</code> function or the <strong>Lambda</strong> function <code>\x -&gt; even x &amp;&amp; x&gt;0</code>.
If the value returns <code>True</code> it will be added to the resulting list,
if the value returns <code>False</code> the item won&rsquo;t be added.</p>
<p>Both examples have used a <strong>Type Class</strong> this is because there are
restrictions that need to be placed on the types of the input.
Looking at the types of the functions in the definition:
<code>even :: Integral a =&gt; a -&gt; Bool</code> and <code>(&gt;) :: Ord a =&gt; a -&gt; a -&gt; Bool</code>
from this we can see we need to add the <code>Integral</code> <strong>Type Class</strong> to our function,
this means that the type of our input has to either be a <code>Integer</code> or <code>Int</code>.
We don&rsquo;t need to include the the <code>Ord</code> type class as well because the <code>Integral</code> type class includes it.
You can check this be using <code>GHCI</code>: <code>:i Ord</code>, I&rsquo;ll leave this as an exercise for the reader,
remember we will be covering <strong>Type Classes</strong> fully later in this series.</p>
<h2 id="map">Map</h2>
<p>The map function has the type <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>, its arguments are a function and a list.
The function is then applied to every item in the list; you can clearly see this from the type signature.</p>
<p>Lets run through an a few examples using the map function, I&rsquo;ll talk through them in the same way I did the in the recursion and list comprehension posts.</p>
<ul>
<li>Create a function that returns the square of all of the elements in a list.
<ul>
<li>When are using high order functions we need to think at a more logical &lsquo;higher&rsquo; level.</li>
<li>Lets think what we have to do to each item, we have to square it.</li>
<li>So lets map across a squaring function</li>
<li>The final function should look something like what is noted below.</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">squareHi</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">squareHi</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>Notice the type signature; the type of the <code>^</code> operator:  <code>(^) :: (Integral b, Num a) =&gt; a -&gt; b -&gt; a</code>,
we must add constraints to the type of our input otherwise we would get a type error, Haskell&rsquo;s favourite error.
This is achieved by using a <strong>Type Class</strong> <code>Num a</code> again I will be covering this later.
The <strong>Haskell Type System</strong> can also infer the type of the function however, this is not best practise - personally I always include a type signature.</p>
<ul>
<li>Create a function that returns the logical  <code>and</code> of a list of <code>Int</code>.</li>
</ul>
<p>Each item is <code>True</code> if the number is greater than <code>5</code> otherwise <code>False</code>.</p>
<ul>
<li>Thinking on a higher level, we know the same function (the one checking the vale) has to be applied to every value. Lets use the <code>map</code> function.</li>
<li>The function that needs to be applied doesn&rsquo;t exist in the standard library (to the best of my knowledge) so lets create our own version of it instead.</li>
<li>The final function and its helper could look like what is shown below.</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">greaterFive</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">greaterFive</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span>     <span class="ow">=</span> <span class="kt">True</span>
              <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">False</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">f</span> <span class="ow">=</span> <span class="n">and</span> <span class="o">.</span> <span class="n">map</span> <span class="n">greaterFive</span>
</code></pre></td></tr></table>
</div>
</div><p>As always let me go through this example in a little detail, our functions are starting to get a little more advanced now.</p>
<p>The <code>greaterFive</code> function is the one that is mapped across each of the values in the list, it is applied to each of the values in the list. This will give us a list of <code>Bool</code> values which then has the <code>and</code> function applied to them.</p>
<p>Lets take note of the <strong>Type Signatures</strong>:
<code>greaterFive</code>: <code>greaterFive :: Int -&gt; Bool</code>,
<code>f</code>: <code>f :: [Int] -&gt; Bool</code>,
<code>and</code>: <code>and :: Foldable t =&gt; t Bool -&gt; Bool</code>; for the minute you can think of <code>Foldable</code> as a <code>List</code>.</p>
<h2 id="fold">Fold</h2>
<p>Now its time to fold. Lets look into how we can use the <code>foldr</code> function in Haskell to write some pretty code.</p>
<p>Let me take you back to when I first introduced the list I said <strong><strong>A list is build not made</strong></strong>.
Every list no matter the type of the elements will have this structure <code>[1,2,3] = 1:(2:(3:[]))</code>.
When we think about folding I like to keep this structure in the front of my mind.</p>
<p><code>foldr</code> has the <strong>Type Signature</strong> <code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</code>,
again think of <code>Foldable</code> and <code>t a</code> both as lists.
So the <code>foldr</code> function takes a function, a value and a list as its inputs.</p>
<p>Lets run through an example to see how we actually use this,
in this example we will be rewriting the <code>and</code> function.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">highAnd</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Bool</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">highAnd</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="kt">True</span> <span class="n">xs</span>

<span class="nf">foldr</span> <span class="p">(</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="kt">True</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x2</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">x3</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p>Above we have an example of an implementation of the <code>and</code> function and how it would be evaluated.
Notice how similar this is to the structure of a list;
the cons operator <code>:</code> has been replaced with a binary operator (a function taking two arguments),
the <code>True</code> value is the identify for <strong>logical and</strong>,
the same way that <code>0</code> is the identify for addition and subtraction
and <code>1</code> is the identify for multiplication and division,
the finally the list that this we will be working with.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">highAnd</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span>
<span class="kt">False</span>
<span class="c1">-- True &amp;&amp; (True &amp;&amp; (False &amp;&amp; (True &amp;&amp; True)))</span>

<span class="kt">GHCI</span><span class="o">&gt;</span> <span class="n">highAnd</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span>
<span class="kt">True</span>
<span class="c1">-- True &amp;&amp; (True &amp;&amp; (False &amp;&amp; (True &amp;&amp; True)))</span>
</code></pre></td></tr></table>
</div>
</div><p>Above we have a few examples of the function being evaluated.
As always lets run through some examples and I will describe how I would approach them.</p>
<ul>
<li>Find the product of all the numbers in a list.
<ul>
<li>We are thinking at a &lsquo;higher&rsquo; level in this post.</li>
<li>We know that we want to have a single result in the end</li>
<li>So lets <strong>fold</strong> that list up then</li>
<li>In this example we are finding the product, lets think of the arguments to the <code>foldr</code> function</li>
<li>Binary Operator: (*), Identity: 1</li>
<li>The final function could look something like this</li>
</ul>
</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">highProd</span> <span class="ow">::</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">highProd</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>This function folds in the multiplication operator into the list and uses <code>1</code> to be the identity fr this operation.</p>
<h2 id="examples">Examples</h2>
<p>I think its time we finally used all three of these together</p>
<ul>
<li>Create a high order function that gives us all of the positive even numbers from a list.
<ul>
<li>We are selecting elements from a list in this example, we are filtering certain elements.</li>
<li>We need to also create a predicate function that evaluated to <code>True</code></li>
</ul>
</li>
</ul>
<p>for positive even numbers and <code>False</code> for the rest.</p>
<ul>
<li>Something like this <code>\x -&gt; even x &amp;&amp; x&gt;0</code> would work,</li>
</ul>
<p>more on this in the next post.</p>
<ul>
<li>We want the function to be able to take both</li>
</ul>
<p><code>Int</code> and <code>Integer</code> types so lets also add a type class.</p>
<ul>
<li>The final solution could look something like this.</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">a</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">a</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">even</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Create a function that returns the square of all of the elements in a list.
<ul>
<li>In this example we need to square all of the numbers in a list.</li>
<li>Since we are applying a function to all of the elements lets use <code>map</code></li>
<li>We will need to apply the square function which with</li>
</ul>
</li>
</ul>
<p><strong>Partial Function Application</strong> we can write as <code>(^2)</code></p>
<ul>
<li>An example solution can be seen below.</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">b</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">b</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Find the product of the square of all the numbers in a list.
<ul>
<li>This question is building on top of the previous.</li>
<li>After we have squared all of the elements in the list</li>
</ul>
</li>
</ul>
<p>we now need to find their product</p>
<ul>
<li>We can do this by folding the list with the multiplication operator <code>*</code>.</li>
<li>The identify for multiplication is <code>1</code> so we will also need to use that.</li>
<li>Since we want to create a function, we will compose the <code>foldr</code> and <code>map</code></li>
</ul>
<p>parts of this question into a single function using the
<strong>Function Composition Operator</strong> <code>.</code>.</p>
<ul>
<li>An example solution can be seen below.</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">c</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">c</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>Define a function that takes a <code>String</code> argument and returns a <code>String</code> containing only the letters of the input but now all lowercase.
<ul>
<li>In this example we need to do two things; remove all of the non-letters</li>
</ul>
</li>
</ul>
<p>and make everything lowercase</p>
<ul>
<li>Lets first filter out all of the letters from our <code>String</code></li>
</ul>
<p>this can be done be done by using the <code>isLetter</code> function
found in the <code>Data.Char</code> library.</p>
<ul>
<li>We then need to make all of these characters</li>
</ul>
<p>(remember Haskell treats a <code>String</code> as <code>[Char]</code>, a list of characters) lowercase
we can do this by using the <code>toLower</code> function again found in <code>Data.Char</code>.</p>
<ul>
<li>After we have done this we will need to compose them using the <code>.</code> operator.</li>
<li>The final function could look something like the this.</li>
</ul>
<!--listend-->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Char</span>

<span class="nf">d</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">d</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">toLower</span> <span class="o">.</span> <span class="n">filter</span> <span class="n">isLetter</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="conclusion">Conclusion</h2>
<p>Finally we have looked at the main ways of getting stuff done <strong>Functionally</strong> in <strong>Haskell</strong>; recursion, list comprehension and high order functions are all ready for us to use.</p>
<p>In the next post we will be looking at <strong><strong>Haskell for Beginners: Lambda Expressions</strong></strong>, we have used them a little in this post but I&rsquo;d like to build on them further as I think they are very cool.</p>
]]></description>
</item></channel>
</rss>
